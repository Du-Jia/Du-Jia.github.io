<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MoDS</title>
      <link href="/2024/08/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E6%95%B0%E6%8D%AE%E5%90%88%E6%88%90%E5%8F%8A%E8%BF%87%E6%BB%A4/MoDS/"/>
      <url>/2024/08/25/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/%E6%95%B0%E6%8D%AE%E5%90%88%E6%88%90%E5%8F%8A%E8%BF%87%E6%BB%A4/MoDS/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="MoDS-Model-oriented-Data-Selection-for-Instruction-Tuning"><a href="#MoDS-Model-oriented-Data-Selection-for-Instruction-Tuning" class="headerlink" title="MoDS: Model-oriented Data Selection for Instruction Tuning"></a>MoDS: Model-oriented Data Selection for Instruction Tuning</h1><p>Paper: <a href="https://arxiv.org/abs/2311.15653" target="_blank" rel="noopener">https://arxiv.org/abs/2311.15653</a></p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>作者提出了一种针对模型做数据选择的框架，从质量、覆盖范围、必要性三个角度评估指令微调数据对于 LLM 指令微调的增益。</p><ul><li>质量：指令本身的质量和相应回复/反馈的质量</li><li>覆盖范围：数据集内数据的多样性</li><li>必要性：对于特定 LLM 微调，指令数据的重要性和独特性<ul><li>如果 LLM 无法针对该指令生成恰当的回复，那么这条数据是重要的/独特的</li></ul></li></ul><h2 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/22546943/1709627600779-0add2341-cba3-4cb5-bcbc-f1f441e7b37f.png?x-oss-process=image%2Fformat%2Cwebp" alt="MoDS方法整体框架"></p><ol><li>用<strong>奖励模型</strong>筛选高质量数据，得到<strong>高质量数据集</strong></li><li>根据<strong>多样性</strong>选取<strong>种子数据</strong>，得到种子数据</li><li>增强指令数据<ul><li>用种子数据训练 LLM，得到种子 LLM</li><li>种子 LLM 为高质量数据集中的不同指令生成回复</li><li>用<strong>必要性</strong>评分模型（筛选高质量数据时用的奖励模型）计算回复的得分，按照阈值过滤不必要数据</li></ul></li><li>最后用选择出的数据微调模型</li></ol><h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><h4 id="不同的维度如何量化"><a href="#不同的维度如何量化" class="headerlink" title="不同的维度如何量化"></a>不同的维度如何量化</h4><ol><li>质量<ul><li>使用奖励模型为每个数据打分，按照阈值过滤低质量数据。</li></ul></li><li>覆盖度（多样性）<ul><li>使用 <strong>BERT</strong> 计算句子表示，计算句子之间的距离</li><li>使用 <strong>K-Center</strong> 方法，贪心选择样本</li></ul></li><li>必要性<ul><li>用种子数据训练模型，为高质量数据生成回复</li><li>用奖励模型评估必要性（奖励模型和质量评估的模型相同）</li></ul></li></ol><p>补充：K-Center 方法</p><p align="center">  <img src="https://cdn.nlark.com/yuque/0/2024/png/22546943/1709627876967-647b4d55-d065-410d-90f3-8bb0ed91c5e6.png?x-oss-process=image%2Fformat%2Cwebp" alt="K-Center方法" width="300"></p><ul><li>先选择一个初始中心点，然后迭代增加新的中心点</li><li>每一步选择离现有中心点最远的点作为新的中心点</li><li>公式说明：对非中心点集合中的点，每一步找到一个离最近中心点最远的点。</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>主要结果：</p><p align="center">    <img src="https://cdn.nlark.com/yuque/0/2024/png/22546943/1709630127549-20977c10-ad6d-4a5f-9bb7-9fb6120bfc06.png?x-oss-process=image%2Fformat%2Cwebp" alt="Main result" width="300"></p><p align="center">    <img src="https://cdn.nlark.com/yuque/0/2024/png/22546943/1709630127549-20977c10-ad6d-4a5f-9bb7-9fb6120bfc06.png?x-oss-process=image%2Fformat%2Cwebp" alt="Main result" width="300"></p><p>对比实验：</p><p align="center">    <img src="https://cdn.nlark.com/yuque/0/2024/png/22546943/1709630127549-20977c10-ad6d-4a5f-9bb7-9fb6120bfc06.png?x-oss-process=image%2Fformat%2Cwebp" alt="Main result" width="300"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出了一种数据选择框架，筛选出一些高质量的种子数据，并实现指令增强，并用必要性评分模型过滤不必要的数据，再混合两者微调模型。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 数据合成及过滤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Selection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础</title>
      <link href="/2024/08/25/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/08/25/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="强化学习入门（一）"><a href="#强化学习入门（一）" class="headerlink" title="强化学习入门（一）"></a>强化学习入门（一）</h1><h2 id="学习资料整理"><a href="#学习资料整理" class="headerlink" title="学习资料整理"></a>学习资料整理</h2><ol><li>强化学习基础学习<ul><li><a href="https://www.bilibili.com/video/BV1XP4y1d7Bk" target="_blank" rel="noopener">李宏毅老师强化学习课程</a></li><li><a href="https://github.com/borninfreedom/DeepLearning/blob/master/Books/RLbook2020.pdf" target="_blank" rel="noopener">Reinforce Learning Book 2020</a></li></ul></li><li>强化学习论文学习<ul><li><a href="https://arxiv.org/pdf/1506.02438.pdf" target="_blank" rel="noopener">GAE论文（优势函数估计）</a></li><li><a href="https://arxiv.org/pdf/2203.02155.pdf" target="_blank" rel="noopener">InstructGPT论文</a></li></ul></li><li>强化学习实践学习<ul><li><a href="https://github.com/CarperAI/trlx" target="_blank" rel="noopener">Trlx代码仓库</a></li><li><a href="https://spinningup.qiwihui.com/zh_CN/latest/spinningup/rl_intro.html" target="_blank" rel="noopener">PlayGround</a></li></ul></li><li>其他相关文章（简单介绍）<ul><li><a href="https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#id20" target="_blank" rel="noopener">https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#id20</a></li><li><a href="https://www.zhihu.com/search?type=content&amp;q=%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0为什么我总感觉强化学习不是真的人工智能？" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0为什么我总感觉强化学习不是真的人工智能？</a></li><li><a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">http://incompleteideas.net/book/the-book-2nd.html</a></li><li><a href="https://www.alexirpan.com/2018/02/14/rl-hard.html" target="_blank" rel="noopener">https://www.alexirpan.com/2018/02/14/rl-hard.html</a></li></ul></li><li>RLHF<ul><li>PPO论文：<a href="https://arxiv.org/pdf/1707.06347.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1707.06347.pdf</a></li><li>PPO拆解：<a href="https://zhuanlan.zhihu.com/p/645225982" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/645225982</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> 数据合成及过滤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
            <tag> 数据合成及过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始复现Transformer</title>
      <link href="/2024/08/25/LLM%E5%9F%BA%E7%A1%80/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E7%8E%B0Transformer/"/>
      <url>/2024/08/25/LLM%E5%9F%BA%E7%A1%80/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%A4%8D%E7%8E%B0Transformer/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始复现Transformer"><a href="#从零开始复现Transformer" class="headerlink" title="从零开始复现Transformer"></a>从零开始复现Transformer</h1><h2 id="Transformer结构介绍"><a href="#Transformer结构介绍" class="headerlink" title="Transformer结构介绍"></a>Transformer结构介绍</h2>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
          <category> Transformer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> LLM </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PromptBERT: Improving BERT Sentence Embeddings with Prompt</title>
      <link href="/2021/12/10/Prompt/PromptBERT%20Improving%20BERT%20Sentence%20Embeddings/"/>
      <url>/2021/12/10/Prompt/PromptBERT%20Improving%20BERT%20Sentence%20Embeddings/</url>
      
        <content type="html"><![CDATA[<h1 id="PromptBERT-Improving-BERT-Sentence-Embeddings-with-Prompt"><a href="#PromptBERT-Improving-BERT-Sentence-Embeddings-with-Prompt" class="headerlink" title="PromptBERT: Improving BERT Sentence Embeddings with Prompt"></a>PromptBERT: Improving BERT Sentence Embeddings with Prompt</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文认为，原始BERT模型在句子语义相似度任务上表现不佳的原因：</p><ol><li>静态token嵌入偏差 (static token embeddings biases)</li><li>无效的BERT层 (ineffective BERT layers)</li></ol><p>而不是因为BERT生成的句子表示的余弦相似度高</p><p><strong>本文的工作</strong>：</p><ol><li>提出了一个基于prompt的<strong>句子嵌入</strong>方法（将sentence embeddings task重构为fill-in-the-black 问题）<ol><li>减少了静态token嵌入偏差</li><li>让原始的BERT更有效</li></ol></li><li>讨论了两种Prompt表示方法以及三种prompt搜索方法</li><li>通过template denoising技术提出了一个新的无监督训练目标</li></ol><h2 id="Instruction"><a href="#Instruction" class="headerlink" title="Instruction"></a>Instruction</h2><p> 1️⃣近年来，在句子表示上，基于BERT的SimCSE等模型有出彩的表现，但是原始的BERT表现很差，甚至不如传统Word Embedding方法GloVe。</p><p>2️⃣有一些研究认为BERT在句子语义相似任务上表现差是因为各向异性(<strong>anisotropy)。</strong>但是比较静态的BERT词向量与最后一层词向量平均池化后的表现(static &gt; last layer)显示，anisotropy不是主要原因。</p><p>3️⃣本文发现，原始的BERT层实际上损害了句子表示的质量。我们发现，分布的偏差不仅和token的频率有关，还对WordPiece中的subword敏感。【通过移除这种高频的subwords或者punctuation，并取其他token的embeddings作为sentence embeddings甚至可以超过BERT-flow和BERT-whitening的表现】</p><p>手动移除偏差token需要大量人力，本文受到prompt方式的启发，提出了一种基于prompt，用模版从BERT中获取句子表示的方法。</p><p>本文提出的方法也可以用于微调。作者发现，通过不同的模版，prompt可以提供更好的生成positive pairs的方法。</p><p>最后，作者提出了一种基于prompt的对比学习方法，这种方法通过template denoising在无监督的设置下利用BERT的能力，能够显著缩短有监督和无监督的表现差距。</p><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>略</p><h2 id="Rethinking-the-Sentence-Embeddings-of-Original-BERT"><a href="#Rethinking-the-Sentence-Embeddings-of-Original-BERT" class="headerlink" title="Rethinking the Sentence Embeddings of Original BERT"></a>Rethinking the Sentence Embeddings of Original BERT</h2><p>作者认为，原始BERT在句子相似度任务上表现不佳的原因是：</p><ul><li>ineffective BERT layers</li><li>static token embeddings biases</li></ul><p>作者通过自己观察到的两种现象验证自己的观点：</p><ol><li><p><strong>Original BERT layers fail to improve the performance</strong>.</p><ul><li><p>衡量句子表示各向异性的方法：</p><p>  $n$为句子的数量，$M$为sentence encoder，$s$为句子</p><p>  <a href="https://imgtu.com/i/o76b4I" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76b4I.png" alt="o76b4I.png"></a></p></li><li><p>比较static embeddings和last layer的平均池化（句子表示）</p><p>  经过BERT的层之后，句子之间的Correlation下降了。</p><p>  各项异性和句子表示的表现没有显示出关联性。</p><p>  （疑问：这里的句子编码是Cross-Encoder还是Bi-Encoder？）</p><p>  <a href="https://imgtu.com/i/o76W36" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76W36.png" alt="o76W36.png"></a></p></li></ul></li><li><p><strong>Embeddings biases harms the sentence embeddings performance</strong>.</p><p> 没理清楚逻辑，之后补</p><ul><li>token embeddings受到token频率(token frequency)、子词(subwords in WordPiece)的影响</li><li>token embeddings 分类：<ul><li>小写开头(lower begin-word tokens)</li><li>大写开头(uppercase begin-word tokens) 【bert-cased】</li><li>子词(subword tokens)</li></ul></li><li><p>下图展示了token frequency，subword对token embeddings分布的影响</p><p>  <a href="https://imgtu.com/i/o765uD" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o765uD.png" alt="o765uD.png"></a></p><p>  移除high frequency token，部分sub word， case等就能带来提升</p><p>  <a href="https://imgtu.com/i/o76fgK" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76fgK.png" alt="o76fgK.png"></a></p></li></ul></li></ol><h2 id="Prompt-Based-Sentence-Embeddings"><a href="#Prompt-Based-Sentence-Embeddings" class="headerlink" title="Prompt Based Sentence Embeddings"></a>Prompt Based Sentence Embeddings</h2><p>核心问题：</p><ol><li>怎样用prompt表示句子</li><li>对于sentence embeddings，怎样找到更好的prompt</li></ol><ul><li><p><strong>represent sentence with the prompt</strong></p><p>  使用模版：<strong>“[X] means [MASK]”</strong></p><p>  两种方法：</p><ol><li><p>直接用[MASK]对应的token embedding作为sentence embedding</p><p> $h=h_{[MASK]}$</p></li><li><p>用[MASK]对应的token embedding，用一个MLM分类器选择最好的top-k个token</p><p> $h=\dfrac{\sum_{v\in V_{top-k}}W_vP([MASK]=v|h_{[MASK]})}{\sum_{v\in V_{top-k}}P([MASK]=v|h_{[MASK]})}$</p><p> 缺点：</p><ul><li>因为使用静态token嵌入取平均得到句子表示，仍然会受到偏差(biases)的影响</li><li>在下游任务上不容易fine-tune</li></ul><p>作者最终采用了第一种方式</p></li></ol></li><li><p><strong>prompt search</strong></p><p>  作者讨论了3种方法用于搜索模板：</p><ol><li><p>手工</p><p> 将模版分成两部分：</p><ul><li>关系token：用于句子和「MASK」之间</li><li><p>前缀token：用于修饰句子（「X」前）</p><p>用贪心的方法搜索</p><p><a href="https://imgtu.com/i/o76R9x" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76R9x.png" alt="o76R9x.png"></a></p></li></ul></li><li><p>基于T5生成</p><p> 用T5生成的最好模版：</p><p> <strong>“Also called [MASK]. [X]”.</strong></p><p> 效果比手工生成的差</p></li><li><p>OptiPrompt (Factual probing is [mask]: Learning vs. learning to recall)</p><p> 用连续模版代替离散模版，在STS-B上能将效果提高到80.90</p></li></ol></li><li><p><strong>prompt based contrastive learning with template denoising</strong></p><p>  常用的方法：dropout，adversarial attack, token shuffling, cutoff and dropout in the input token embeddings</p><p>  作者的方法：</p><p>  <strong>用不同的模版对同一个句子生成句子表示，取为positive pairs。</strong></p><p>  方法描述：</p><p>  给定句子$x_i$</p><ol><li>用一个模版计算对应的句子表示$h_i$</li><li>计算模版偏差$\hat{h_i}$：直接送入一个模版和相同的template ids</li><li>用$h_i$$-\hat{h_i}$作为降噪后的句子表示</li><li><p>用$h_i’,\hat{h_i’}$表示用另一个模版生成的句子表示</p><p> 优化下述训练目标：</p><p> $l_i=-log\dfrac{e^{cos(h_i-\hat{h_i}, h_i’-\hat{h_i’})/t}}{\sum_{j=1}^{N} e^{cos(h_i-\hat{h_i},h_j’-\hat{h_j’})/t}}$</p></li></ol></li></ul><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><ul><li>数据集<ul><li>STS</li><li>STS-B</li><li>SICKR</li></ul></li><li>Baselines<ul><li>non fine-tuned:<ul><li>GloVe</li><li>BERT-flow</li><li>BERT-whitening</li></ul></li><li>fine-tuned<ul><li>IS-BERT</li><li>InferSent</li><li>Universal Sentence Encoder</li><li>SBERT</li><li>SimCSE</li><li>ConSERT</li></ul></li></ul></li><li>Implementation Details</li><li><p>Non fine-tuned</p><p>  <a href="https://imgtu.com/i/o76g41" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76g41.png" alt="o76g41.png"></a></p></li><li><p>fine-tuned</p><p>  <a href="https://imgtu.com/i/o76oHH" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76oHH.png" alt="o76oHH.png"></a></p></li><li><p>ablation</p><p>  <a href="https://imgtu.com/i/o76IDe" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76IDe.png" alt="o76IDe.png"></a></p></li></ul><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><h3 id="Template-Denoising"><a href="#Template-Denoising" class="headerlink" title="Template Denoising"></a>Template Denoising</h3><p>该方法可以移除无关的词汇，例如nothing, no ,yes</p><p>只在对比训练目标函数中使用了该方法，可以帮助消除偏差</p><p><a href="https://imgtu.com/i/o767Ed" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o767Ed.png" alt="o767Ed.png"></a></p><h3 id="Stability-in-Unsupervised-Contrastive-Learning"><a href="#Stability-in-Unsupervised-Contrastive-Learning" class="headerlink" title="Stability in Unsupervised Contrastive Learning"></a>Stability in Unsupervised Contrastive Learning</h3><p>用10个不同的随机种子训练模型，与SimCSE对比，PromptBERT的最好和最坏结果差值只有0.53%，SimCSE的差值为3.14%</p><p><a href="https://imgtu.com/i/o76HUA" target="_blank" rel="noopener"><img src="https://s4.ax1x.com/2021/12/11/o76HUA.png" alt="o76HUA.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
          <category> Prompt Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch-SGD-求函数最优值</title>
      <link href="/2021/05/07/pytorch/PyTorch-SGD-%E6%B1%82%E5%87%BD%E6%95%B0%E6%9C%80%E4%BC%98%E5%80%BC/"/>
      <url>/2021/05/07/pytorch/PyTorch-SGD-%E6%B1%82%E5%87%BD%E6%95%B0%E6%9C%80%E4%BC%98%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="面试遇到的一个基础问题：使用PyTorch求一个函数的最优值"><a href="#面试遇到的一个基础问题：使用PyTorch求一个函数的最优值" class="headerlink" title="面试遇到的一个基础问题：使用PyTorch求一个函数的最优值"></a>面试遇到的一个基础问题：使用PyTorch求一个函数的最优值</h1><p>代码如下：</p><pre class=" language-lang-(python3)"><code class="language-lang-(python3)">import torch.optim as optimimport torch# 参数为x，(1,1)x = torch.randn([1],requires_grad=True)def function(x):    return x**2 - 2*x + 1optimizer = optim.SGD([x], lr=0.01, momentum=0)for step in range(11):    y = torch.cos(x)    optimizer.zero_grad()    y.backward()    optimizer.step()   #求一次SDG    print('step {}: x={},y={}'.format(step, x[0], y[0]))</code></pre><p>这里将<code>x</code>作为需要优化的参数，每次梯度下降更新<code>x</code>的值，直到目标函数的值达到最小</p><p>这里<code>y</code>即是目标函数</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Pytorch </tag>
            
            <tag> 深度学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Me</title>
      <link href="/2020/12/29/about/me/"/>
      <url>/2020/12/29/about/me/</url>
      
        <content type="html"><![CDATA[<h1 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h1><p><a href="https://imgchr.com/i/rHH6sI" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2020/12/29/rHH6sI.jpg" alt="图片来自网络"></a></p><h2 id="学习经历"><a href="#学习经历" class="headerlink" title="学习经历"></a>学习经历</h2><div class="table-container"><table><thead><tr><th style="text-align:center">学习阶段</th><th style="text-align:center">学校</th><th style="text-align:center">专业</th><th style="text-align:center">研究方向</th></tr></thead><tbody><tr><td style="text-align:center">研究生</td><td style="text-align:center">北京邮电大学</td><td style="text-align:center">计算机技术</td><td style="text-align:center">自然语言处理</td></tr><tr><td style="text-align:center">本科</td><td style="text-align:center">北京信息科技大学</td><td style="text-align:center">计算机科学与技术</td><td style="text-align:center">自然语言处理</td></tr></tbody></table></div><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><ul><li>科大讯飞，初级算法研究工程师（2023.07 - 至今）</li></ul><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><ul><li>滴滴 - 用户画像（2021.05 - 2021.08）</li><li>度小满 - AI Lab（2021.09 - 2022.07）</li><li>澜舟科技 - 搜索组（2022.07 - 2022.09）</li></ul><h2 id="论文发表"><a href="#论文发表" class="headerlink" title="论文发表"></a>论文发表</h2><ul><li><a href="https://aclanthology.org/2022.findings-emnlp.285/" target="_blank" rel="noopener">IGATE: Instance-Guided Prompt Learning for Few-Shot Text-Matching.Accepted by findings of EMNLP2022.</a></li></ul><p><strong>联系方式：</strong></p><p>E-mail: jia_du@foxmail.com</p><p><strong>P.S.</strong> 如果你发现文章有错误，可以通过邮件或者评论留言的方式向我提出，我会作出修改，感谢！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch_basic</title>
      <link href="/2020/09/22/pytorch/pytorch-basic/"/>
      <url>/2020/09/22/pytorch/pytorch-basic/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/wOfiUP" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/22/wOfiUP.jpg" alt="封面"></a></p><h1 id="pytorch-baisc"><a href="#pytorch-baisc" class="headerlink" title="pytorch baisc"></a>pytorch baisc</h1><p>最近用Pytorch的时候发现对于pytorch的一些细节问题掌握不够充分。包括整个框架的使用流程，Tensor的一些初始化，类型转换的细节也理解的不是很深。为了方便以后能够更从容的使用Pytorch，重新学习以下Pytorch的一些基础内容，并对重点做一下记录。</p><p>目前大致按照官方tutorials的顺序记录，随着学习的深入和对文档的查阅慢慢补充。</p><h2 id="Basic-Tensor"><a href="#Basic-Tensor" class="headerlink" title="Basic - Tensor"></a>Basic - Tensor</h2><p><strong>包</strong>： <code>torch.Tensor</code></p><ol><li><p>Tensor的创建</p><ul><li><p>直接创建，不初始化： <code>torch.empty()</code></p><p>  e.g., <code>torch.empty(5, 3, dtype=torch.long)</code></p><p>  其中内部的参数是tensor的形状</p><p>相应的，有如下的初始化方式，参数均和上述一致：</p></li><li><p>随机初始化: <code>torch.rand()</code></p></li><li>0值初始化:<code>torch.zeros()</code></li><li>列表初始化：<code>torch.tensor(A_List)</code></li><li><p>用已有Tensor初始化：<code>torch.new_ones()</code>(<em>除非指定数据类型，否则和输入的tensor数据类型相同</em>)</p><pre class=" language-lang-(python)"><code class="language-lang-(python)">  x = x.new_ones(5, 3, dtype=torch.double)  # new_* methods take in sizes  print(x)  x = torch.randn_like(x, dtype=torch.float)  # override dtype!  print(x)</code></pre></li></ul></li><li><p>操作</p><ul><li>形状相同可以直接四则运算(<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)，这样的运算是对应位置上的元素在运算</li><li>四则运算函数，返回一个运算结果，可以通过out参数将结果输出到给定tensor：</li><li><code>torch.add(x, y)</code></li><li><code>torch.sub(x, y)</code></li><li><code>torch.mul(x, y)</code></li><li><code>torch.div(x, y, out=result)</code></li><li>原地运算，函数名后缀为下划线的函数，运算结果直接在对应Tensor上改变。</li><li><code>y.add_(x)</code></li><li><code>x.copy_(y)</code></li><li><code>x.t_()</code></li></ul></li><li><p>索引</p><ul><li>可以用numpy数组的索引方式来索引tensor</li><li>如果一个tensor只有一个元素，可以使用<code>x.item()</code>获得该元素</li></ul></li><li><p>改变Tensor形状</p><ul><li><p><code>view()</code>：</p><p>  <code>view()</code>函数接受的参数即是需要修改后的形状。</p><p>  <code>x.view(16)</code>: 将x改为长度为16的向量</p><p>  <code>x.view(-1, 8)</code>: -1表示其他不确定的维度，这个维度需要根据第二个参数8计算出来。例如., 此处x原始的形状为(4,4);那么第二个维度的大小为8，可以计算出第一个维度的大小为2，则新的x的形状为：(2,8)</p></li></ul></li><li><p>numpy.ndarray -&gt; tensor:</p><ul><li><p>如何转化：</p><pre class=" language-lang-(python)"><code class="language-lang-(python)">  # converting numpy array to torch tensor  import numpy as np  a = np.ones(5)  b = torch.from_numpy(a)  np.add(a, 1, out=a)  print(a)  print(b)  # tensor to numpy  a = torch.ones(5)  b = a.numpy()</code></pre><p>可以通过<code>tensor_name.numpy()</code>方法将一个Tensor转化为numpy数组。</p><p><strong>通过Tensor转化的Numpy和原始的Tensor共享内存</strong>：</p><p>也就是说，如果你修改得到的Numpy数组，相应的Tensor内容也会变化。（类似指针操作）</p><p>同理，使用numpy数组生成的Tensor和原始numpy数组也有这样的关系。</p></li></ul></li><li><p>使用GPU</p><p> 使用<code>.to()</code>函数将变量转为GPU数据。</p><p> eg.,</p><pre class=" language-lang-（python）"><code class="language-lang-（python）"> # let us run this cell only if CUDA is available # We will use ``torch.device`` objects to move tensors in and out of GPU if torch.cuda.is_available():     device = torch.device("cuda")          # a CUDA device object     y = torch.ones_like(x, device=device)  # directly create a tensor on GPU     x = x.to(device)                       # or just use strings ``.to("cuda")``     z = x + y     print(z)     print(z.to("cpu", torch.double))       # ``.to`` can also change dtype together!</code></pre></li></ol><p>参考<a href="https://pytorch.org/docs/stable/torch.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="Basic-Autograd-自动求导"><a href="#Basic-Autograd-自动求导" class="headerlink" title="Basic - Autograd, 自动求导"></a>Basic - Autograd, 自动求导</h2><p><strong>包</strong>：<code>torch.autograd</code>, <code>torch.Function</code></p><p>Function: <a href="https://pytorch.org/docs/stable/autograd.html#function" target="_blank" rel="noopener">参考文档</a></p><p><code>autograd</code>这个包为所有在张量上的操作提供了自动求导的功能。</p><p>该框架是在运行时定义的，因此反向传播的方式由代码运行的方式定义，每次迭代都可以不同。</p><ol><li><p><code>requires_grad</code>和<code>grad</code>属性</p><ul><li><code>requires_grad</code>属性，<code>boolean</code>类型，<code>True</code>表示需要自动计算梯度</li><li><code>grad</code>：存储自动计算的梯度</li><li><code>requires_grad_()</code>方法可以改变一个<code>Tensor</code>的该属性的值</li></ul></li><li><p>停止追踪历史计算</p><ul><li><p><code>.detach()</code>：避免张量追溯历史记录或者被之后的计算追溯。(不太明白，后续修改补充。原句：<em>To stop a tensor from tracking history, you can call .detach() to detach it from the computation history, and to prevent future computation from being tracked.</em>)</p><p>如果需要使用一个<code>.requires_grad</code>属性为<code>True</code>的变量，但是又不想对这个变量做的操作被追溯（计算梯度），可以使用<code>.detach()</code>方法得到该变量的副本，并且副本的该属性默认为<code>False</code></p></li></ul></li><li><p>避免追踪历史记录或者使用内存：</p><ul><li>将代码块写在<code>with_torch.no_grad():</code>下。该方法下的代码块在执行时将不会自动计算梯度或者更新参数。适合在对已经训练好的模型测试，评估时使用。</li></ul></li><li><p>自动求导过程中最重要的类：<code>Function</code></p><ul><li><code>Tensor</code>和<code>Function</code>是相关联的，二者一起构建了一个非循环图以编码一个完整的计算过程。</li><li><code>.grad_fn</code>：指向了生成这个<code>Tensor</code>的<code>Function</code>。当属性值为<code>None</code>，表示这个<code>Tensor</code>是由用户创建的</li></ul></li><li><p>求导：<code>.backward()</code></p> <font color="red">此处存疑，未能完全理解</font><p> 使用<code>.backward()</code>求导需要注意的问题：</p><ol><li>如果该<code>Tensor</code>是一个标量，不需要特别指定参数</li><li><p>如果该<code>Tensor</code>含有不止一个元素，需要指定一个<code>gradient</code>参数，这个参数是一个形状匹配的<code>Tensor</code></p><p><code>autograd</code>是一个计算向量-雅可比矩阵乘积的引擎</p><p>下面对此详细说明：</p><p>实际上，<code>.backward()</code>是需要参数的。只不过当<code>Tensor</code>是一个标量的时候，默认方法实质上等价于<code>.backward(torch.tensor(1.))</code>, <code>autograd</code>引擎实际上计算的是$1.0*\dfrac{d(o)}{dx}$，其中1.0被理解为$\dfrac{dl}{do}=1.0$</p><p>把<code>.backward()</code>的形参视为$v$，最终计算的值其实是$J^T\dotv$。（为什么不是$v^T\dotJ$, 因为前者得到的是列向量）</p></li></ol></li><li><p>原始教程</p></li></ol><p><a href="https://pytorch.org/tutorials/beginner/blitz/autograd_tutorial.html" target="_blank" rel="noopener">点击此处查看原始教程</a></p><h2 id="Basic-Neural-Network"><a href="#Basic-Neural-Network" class="headerlink" title="Basic - Neural Network"></a>Basic - Neural Network</h2><p><strong>包</strong>：<code>torch.nn</code></p><p>重点内容:</p><ul><li>定义模型</li><li><code>nn.Module</code></li><li><code>forward(input)</code></li></ul><ol><li><p>模型训练流程</p><ul><li>定义神经网络，定义可学习的参数</li><li>遍历输入数据集</li><li>处理输入</li><li>计算损失值</li><li>计算梯度</li><li>更新权重</li></ul></li><li><p>定义网络</p><ul><li>继承<code>nn.Module</code></li><li>重写<code>__init__()</code></li><li><p>重写<code>forward()</code></p><p>模型的参数</p></li><li><p><code>model.parameters()</code>方法返回模型中的参数</p></li><li><code>model(input)</code>直接调用<code>forward()</code>方法，返回前馈网络的传播。</li><li><p><code>model.zero_grad()</code>，在反向传播前，应该清空上一次迭代的梯度</p><p><strong>重点</strong>：</p></li><li><p><code>torch.nn</code>只支持mini-batches输入。也就是说，整个<code>troch.nn</code>包中的方法都只支持使用mini-batches作为输入，不支持单个样本的输入。例如2为卷积层接收的输入应该是一个4维的张量，这个张量各个维度的意义是：样本数，通道数，高度，宽度。</p></li><li>如果确实需要输入单个样本，可以考虑使用<code>.unsqueeze(0)</code>方法，为样本增加一个维度。</li></ul></li><li><p>计算loss值</p><p> Loss Function接受一个张量对<code>(output, target)</code>作为输入，并且计算输出和目标值的差距。</p><p> 有很多常用的Loss函数，这里不一一写出，详情参考<a href="https://pytorch.org/docs/stable/nn.html#loss-functions" target="_blank" rel="noopener">Loss Function</a></p> <font color="res">关于Loss函数的一些细节问题之后补充</font></li><li><p>反向传播</p><p> 示例：</p><pre class=" language-lang-(python)"><code class="language-lang-(python)"> net.zero_grad() # zeroes the gradient buffers of all parameters print('conv1.bias.grad before backward') print(net.conv1.bias.grad) loss.backward() print('conv1.bias.grad after backward') print(net.conv1.bias.grad)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Pytorch </tag>
            
            <tag> 深度学习基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS224N Lecture 8 Notes</title>
      <link href="/2020/08/18/CS224N/CS224N-Lecture-8-Notes/"/>
      <url>/2020/08/18/CS224N/CS224N-Lecture-8-Notes/</url>
      
        <content type="html"><![CDATA[<h1 id="CS224N-Lecture-8-Notes"><a href="#CS224N-Lecture-8-Notes" class="headerlink" title="CS224N Lecture 8 Notes"></a>CS224N Lecture 8 Notes</h1><p>任务: <strong>Neural Machine Translation</strong></p><p>结构: <strong>Seqence-to-Sequence</strong></p><p>技巧: <strong>Attention</strong></p><p>注：本文所用图片为从课程slides中截取</p><p>之前的课程讲到的任务都没有涉及整个句子的输出，Lecture 8的内容就着眼与这个部分。类似的任务有：</p><ol><li>翻译</li><li>对话</li><li>文本摘要</li></ol><p>类似的任务都是需要输入一个句子（或者更长）并且输出一个句子，Sequence-to-Sequence模型适合解决这类问题。</p><h2 id="统计机器翻译-SMT-Statistical-Machine-Translation"><a href="#统计机器翻译-SMT-Statistical-Machine-Translation" class="headerlink" title="统计机器翻译 SMT(Statistical Machine Translation)"></a>统计机器翻译 SMT(Statistical Machine Translation)</h2><hr><h3 id="翻译模型"><a href="#翻译模型" class="headerlink" title="翻译模型"></a>翻译模型</h3><p>给定一种语言的句子$x$ (Sentence)，求出与之对应的可能性最大的另一种语言的句子$y$</p><script type="math/tex; mode=display">argmax_y P(y|x) = argmax_yP(x|y)P(y) \\(Bayes Rule)</script><h3 id="SMT的训练"><a href="#SMT的训练" class="headerlink" title="SMT的训练"></a>SMT的训练</h3><p>通过平行语料训练，相当于一个解码的过程。主要通过统计方式，用启发式搜索算法计算</p><p><img src="https://s1.ax1x.com/2020/08/18/duEXuV.png" alt="罗塞塔石碑">)</p><p>存在以下问题：</p><ol><li><p>对齐问题(alignment)：</p><p> 两种语言的词在句中的位置可能不是一一对应，可能出现无对应，一对多，多对一，多对多（短语对应短语）等情况出现</p><ul><li>多对一<br><a href="https://imgchr.com/i/duZDWd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/18/duZDWd.md.png" alt="多对一"></a></li><li>一个词对应一个短语<br><a href="https://imgchr.com/i/duZsSA" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/18/duZsSA.md.png" alt="一对多"></a></li><li>一对多<br><a href="https://imgchr.com/i/duZBJH" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/18/duZBJH.md.png" alt="一对多"></a></li></ul></li><li>一词多义</li></ol><h2 id="神经机器翻译-NMT-Nerual-Machine-Translation"><a href="#神经机器翻译-NMT-Nerual-Machine-Translation" class="headerlink" title="神经机器翻译 NMT(Nerual Machine Translation)"></a>神经机器翻译 NMT(Nerual Machine Translation)</h2><hr><h3 id="Seq2Seq模型"><a href="#Seq2Seq模型" class="headerlink" title="Seq2Seq模型"></a>Seq2Seq模型</h3><p>Seq2Seq模型是一种端到端(end-to-end)模型</p><p>由两个循环神经网络组成(RNN)</p><ul><li><p>Encoder:</p><p>  将输入的序列编码为一个固定大小的“上下文向量”</p><p>  Encoder的最后一个时间步输出的隐藏状态$h$就是“上下文向量”$C$，其网络常采用LSTM。</p><p>  Encoder会<strong>逆序</strong>处理输入的序列，这样可能让EEncoder最开始读入的信息对应最后的输出。Decoder的获取的第一个输入可能会提高其生成合适序列的概率。</p></li><li><p>Decoder：</p><p>  将encoder产生的“上下文向量”用于初始化Decoder的隐藏状态。</p><p>  Decoder是一个语言模型（Language Model，LM）。每个时间步生成的内容又作为下一个时间步的输入。当隐藏状态设置好，就可以开始生成序列了。</p><p>  <strong>生成序列</strong>：</p><p>  Decoder的输入是一个代表开始的特殊表示<code>&lt;start&gt;</code>。并且需要在输入的最后加上表示结束的特殊表示<code>&lt;EOS&gt;</code>，同时这个表示也是输出的结束标志。接下来就按照时间步计算输出序列即可。</p></li></ul><p><strong>训练</strong>：</p><p>在Seq2Seq模型中，定义预测序列的交叉熵(cross-entropy loss)作为模型损失，训练目标就是最小化这个损失。</p><h3 id="NMT"><a href="#NMT" class="headerlink" title="NMT"></a>NMT</h3><p>神经机器翻译采用Seq2Seq模型结构，由两个RNN网络构成。一个RNN作为编码器， 一个RNN作为解码器构成。</p><ul><li>编码器(Encoder)：<br>  负责提取输入的句子的信息，并传递给解码器使用。输出的是输入句子的编码信息。</li><li>解码器(Decoder)：<br>  解码器实际上是一个语言模型(Language Model, LM)，作用是通过编码器传来的信息生成目标语言的句子。</li><li><p>注意：</p><p>  解码器起始输入为<code>&lt;start&gt;</code>。解码器每个单元产生的输出会作为下一个单元的输入。直到产生一个<code>&lt;end&gt;</code></p><p>  编码器和解码器之间没有连接，因此输入语句的长度是任意的，输出语句的长度也是任意的，二者的长度并不一致。</p></li></ul><p>网络结构如下：</p><p><a href="https://imgchr.com/i/dumSUS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/08/18/dumSUS.md.png" alt="NMT网络结构图"></a></p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>模型直接计算：</p><script type="math/tex; mode=display">P(y|x)=\sum_{i=1}^TP(y_i|y_1, ..., y_{i-1},x)</script><p>其中$y$为目标句子，$x$为输入的句子。$y_i$是输出的第$i$个单词。上式描述了解码器生成句子$y$的概率。</p><p>训练，最小化损失函数。Decoder每一个时间步的负log损失相加，就是模型的总损失：</p><script type="math/tex; mode=display">J=\dfrac{1}{T}\sum_{i=1}^{T}J_t</script><h3 id="Decoder怎样求出目标句子"><a href="#Decoder怎样求出目标句子" class="headerlink" title="Decoder怎样求出目标句子"></a>Decoder怎样求出目标句子</h3><ul><li>基础方法：贪心编码<ul><li>每次都求出当前评分最高的句子</li><li>缺点：不能回退</li></ul></li><li>暴力方法：搜索所有可能编码<ul><li>每次都搜索所有可能行</li><li>缺点：计算复杂度高，代价昂贵</li></ul></li><li>Beam search decoding<ul><li>每次选出前$k$种可能性最高的词，然后对每种可能作出评分，留下$k$个可能性最高的编码</li><li>停止条件：<ul><li>规定数目的编码终止(生成了<code>&lt;end&gt;</code>)</li><li>达到规定的时间步</li></ul></li></ul></li><li><p>对句子的评分：</p><ol><li><p>上述每种方法，都需要对句子进行评分然后比较，评分公式如下：</p><script type="math/tex; mode=display">Score(y_1,...,y_t) = logP_{LM}(y_1,...,y_t|x)=\sum_{i=1}^t\log{P_{LM}(y_i|y_1,...,y_{i-1},x)}</script></li><li><p>改进：由于句子长度对评分有所影响（句子越长，评分越低）因此对评分做规范化(Normalize)处理</p><script type="math/tex; mode=display">Score(y_1,...,y_t) = \dfrac{1}{t}logP_{LM}(y_1,...,y_t|x)=\dfrac{1}{t}\sum_{i=1}^t\log{P_{LM}(y_i|y_1,...,y_{i-1},x)}</script></li></ol></li></ul><h3 id="改进：双向循环神经网络"><a href="#改进：双向循环神经网络" class="headerlink" title="改进：双向循环神经网络"></a>改进：双向循环神经网络</h3><p>最基本的NMT结构中，编码器和解码器中的信息都是单向流动的，但是在句子中，词和词之间的依赖不一定是单向的，因此，通过在编码器和解码器中增加一个方向的RNN，实现双向的RNN结构，有助于获取词和词之间在两个方向上的依赖信息。</p><p>由于采用了两个方向的RNN，编码层产生的“上下文向量”也就有了两个：一个正向，一个反向（reverse context vector, forward context vector）。用于初始化解码器中的对应方向的RNN网络。</p><p>采用双向循环神经网络的编码器：</p><p><img src="https://s1.ax1x.com/2020/08/18/dKmQld.png" alt="双向循环神经网络编码器"></p><h3 id="NMT的优缺点"><a href="#NMT的优缺点" class="headerlink" title="NMT的优缺点"></a>NMT的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>表现比SMT更好</li><li>只需要一个单独的神经网络就能完成训练</li><li>更少的特征工程</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>可解释性差</li><li>很难控制</li></ol><h3 id="NMT的难点"><a href="#NMT的难点" class="headerlink" title="NMT的难点"></a>NMT的难点</h3><ol><li>超出词汇表(out-of-vocabulary)</li><li>领域不匹配(Domin mismatch)</li><li>难以从长文本中获取信息</li><li>一些语言的训练语料很少（NMT需要大量训练语料）</li><li>偏见（训练出的模型在处理一些句子时会出现偏向某一个性别的现象）</li><li>可解释性差</li></ol><h2 id="注意力机制-Attention"><a href="#注意力机制-Attention" class="headerlink" title="注意力机制 (Attention)"></a>注意力机制 (Attention)</h2><hr><ul><li><p>来源：</p><p>  一个输入中的不同部分应该具有不同等级的重要性。</p><p>  例如：</p><p>  <em>input:</em> the ball is on the filed</p><p>  句中的每个单词的重要性是不同的，ball和filed两个单词的重要性明显更高。</p></li><li><p>作用：</p><p>  注意力机制的作用就在于：</p><p>  为解码器的每个时间步都提供了输入句子的全局信息（这个信息经过注意力机制后强调了重点部分），因此在不同的时间步，解码器可以决定哪些输入的内容在当前是重要的。</p></li><li><p>注意力机制图示：</p></li></ul><p><img src="https://s1.ax1x.com/2020/08/18/duELj0.png" alt="注意力机制"></p><ul><li><p>为什么要使用注意力机制：</p><p>  基本的NMT模型中，编码器的最后一个时间步的输出隐状态传送到解码器中作为输入。当句子较长的时候，很难获取到较远时间步的信息。</p><p>  引入注意力机制就是为了捕获原句中的所有信息（重要信息）</p></li><li><p>结构</p><p>  上图为解码器在最后一个时间步使用Attention的图示。</p><p>  注意力机制获取编码器中每个时间步的输出，结合解码器中当前时间步的输出，通过<code>scores</code>函数求出相应的评分，得到其分布情况(Attention Distribution)。而后通过<code>softmax</code>得到注意力层的输出(Attention output)。然后将注意力层的输出和解码器该时间步的隐含状态拼接起来按照和未使用注意力机制时一样的处理方式处理。</p><p>  具体的公式如下：</p><ul><li><p>score函数</p><script type="math/tex; mode=display">e^t = [s_t^Th_1,...,s_t^Th_N]</script></li><li><p>使用softmax函数计算分布：</p><script type="math/tex; mode=display">\alpha^t = softmax(e^t)</script></li><li><p>计算Attention output</p><script type="math/tex; mode=display">a_t=\sum_{i=1}^N\alpha^t_ih_i</script></li><li><p>连接注意力层的输出和解码器的隐含状态：</p><script type="math/tex; mode=display">[a_t;s_t]</script></li><li>其中$e^t$表示attention scores, $\alpha^t$是其分布，$a_t$是注意力层最终的输出，$s_t$是当前解码器时间步输出的隐藏状态。</li></ul></li></ul><h3 id="注意力机制的作用"><a href="#注意力机制的作用" class="headerlink" title="注意力机制的作用"></a>注意力机制的作用</h3><ol><li>提高NMT的表现，打破NMT的瓶颈，并且对梯度消失问题有所帮助</li><li><p>为NMT模型提供了一定的可解释性</p><ul><li>通过注意力层的评分，可以观察到句子中哪些信息比较重要</li><li>网络自学习到了关于不同语言单词对齐(alignment)的信息</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第8课主要涉及以下内容：</p><ol><li>Machine Translation的历史：SMT</li><li>基本的Neural Machine Translation（NMT）架构Seq2Seq</li><li>NMT的优缺点及难点</li><li>引入注意力机制解决编码器捕获长序列信息的瓶颈</li></ol><p>PS: 对于Lecture内中提及的其他模型及对NMT结果的评估部分内容未完成，后续逐渐补充</p>]]></content>
      
      
      <categories>
          
          <category> CS224N笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 笔记 </tag>
            
            <tag> CS224N </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning Notes - Week 1</title>
      <link href="/2020/08/05/other/Deep-Learning-Notes-Week-1/"/>
      <url>/2020/08/05/other/Deep-Learning-Notes-Week-1/</url>
      
        <content type="html"><![CDATA[<h1 id="NLP入门计划第一周-笔记"><a href="#NLP入门计划第一周-笔记" class="headerlink" title="NLP入门计划第一周 - 笔记"></a>NLP入门计划第一周 - 笔记</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ol><li>了解感知机/多层感知机(MLP)</li><li>了解<strong>前向传播</strong>，<strong>反向传播</strong>，<strong>微积分</strong>， <strong>偏导</strong>的基本知识</li><li>梯度下降，学习率，梯度裁剪</li><li>了解常用的激活函数，从$tanh$到$gelu$</li><li>了解<strong>loss function</strong>, <strong>cross-entropy</strong>, <strong>平方差</strong></li></ol><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>由于之前有过一点深度学习基础，不算是完全从零开始学起，此次做笔记的目的在于加深对深度学习基础知识的了解，特别是补了一下一些数学上的理论知识。经验浅薄，有所疏漏在所难免。</p><h3 id="感知机-Perceptron"><a href="#感知机-Perceptron" class="headerlink" title="感知机(Perceptron)"></a>感知机(Perceptron)</h3><p>感知机用于线性可分数据的二分类任务，基本思想是通过求解能够划分两类数据的直线或者超平面以达到分类的目的。</p><p>按照《统计学习方法》一书的介绍，下面从<strong>模型</strong>，<strong>策略</strong>，<strong>算法</strong>三块来介绍。</p><ol><li><p>模型</p><p> 感知机可以表示为如下形式:</p><script type="math/tex; mode=display">f(x) = sign(wx + b)</script><p> 即一个空间上的超平面。其中$w$为该超平面的斜率，$b$为该超平面的截距。</p><p> 最终学习的目标就是学习到一个能够把数据点分到该朝平面两侧的超平面。</p></li><li><p>学习策略</p><ul><li><p>误分类点：</p><p>  误分类点即被超平面错误分类的点，其$f(x)$值和实际的标签$y$恰好相反</p><p>  误分类点可以提供修正模型的数据</p></li><li><p>损失函数：</p><p>  即误分类点到超平面的总距离，最终的目标就是让该值尽可能小</p><p>  损失函数表示如下：</p><script type="math/tex; mode=display">-\dfrac{1}{\|w\|}\displaystyle\sum_{x_i\in M}|w\cdot{x_i}+{b}|</script></li></ul></li><li><p>训练算法</p><p> 随机梯度下降</p><p> 思想：随机初始化超平面，<strong>每次</strong>随机选择<strong>一个</strong>误分类点使超平面梯度下降，不断重复，直到所有点被正确分类或者损失函数达到一个<strong>阈值</strong>（如果是线性不可分的数据是不可能求出能正确分类的超平面的）</p></li></ol><h3 id="多层感知机-multilayer-perceptron"><a href="#多层感知机-multilayer-perceptron" class="headerlink" title="多层感知机(multilayer perceptron)"></a>多层感知机(multilayer perceptron)</h3><p>$多层感知机(MLP) = 人工神经网络(ANN)$</p><p>单层感知机只能处理线性可分的数据，因此遇到更复杂的数据时，感知机就没有作用了。</p><p>多层感知机的结构如下图所示（这里使用了一张别人博客中的图片，<a href="https://www.cnblogs.com/jaww/p/12302543.html" target="_blank" rel="noopener">点击此处</a>跳转到博客原文）：</p><p><img src="https://img2018.cnblogs.com/i-beta/1473572/202002/1473572-20200213100738646-47348751.png" alt="多层感知机"></p><p>如上图所示，多层感知机其实就是一个全连接的神经网络。上图所示为一个含一层隐含层的网络。这里的$h_1 = w_1x + b$实际上就是一个感知机，多个感知机层叠到一起，构成了一个多层感知机。</p><p>但是，如果隐藏层的单元$h_1, h_2, …, h_n$如果直接输入到下一层，那么该多层感知机实际上仍然只能处理线性可能的数据，也即是说，仍然等价于一个单层的感知机，只不过参数更多更复杂而已。要使其能够处理非线性可分的数据，必须加入激活函数（引入非线性），这时隐含层的单元值有所变化，下面以$h_1$为例：</p><script type="math/tex; mode=display">h_1 = sigmoid(w_1x + b)</script><p>这样的网络，才是一个真正的多层感知机。</p><h3 id="前向传播-forward-propagation"><a href="#前向传播-forward-propagation" class="headerlink" title="前向传播(forward propagation)"></a>前向传播(forward propagation)</h3><p>如前节，按照图中的描述，输入层数据$X$经过计算可以得到隐含层数据$H$，再由隐含层数据经过计算得到输出层的数据$O$，这样一个过程，就是前向传播。</p><h3 id="反向传播-backpropagation"><a href="#反向传播-backpropagation" class="headerlink" title="反向传播(backpropagation)"></a>反向传播(backpropagation)</h3><p>模型的训练过程即是求解<strong>目标函数</strong>最优值的过程。（目标函数即是代价函数，用于衡量训练结果和实际标签的差异）</p><p>反向传播即是通过<strong>梯度下降</strong>方法，从最后一层开始，使用每一层的梯度值逐层更新每一层的参数值，最终不断逼近最优解（可能是局部最优）</p><h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p>每次更新的幅度大小，$0 &lt;= lr &lt;= 1$</p><h3 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h3><p>当函数的偏导值接近0，会出现梯度消失（即该参数无法通过梯度进行更新）。梯度消失和激活函数的选取以及网络结构有关。</p><p><strong>梯度爆炸的原因暂时还未理解，后续补坑。</strong></p><h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>可以防止梯度爆炸问题发生</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>常用激活函数及其导数</p><ol><li>sigmoid<ul><li>原函数<script type="math/tex; mode=display">sigmoid(x)=\dfrac{1}{1+e^{-x}}</script></li><li>导数<script type="math/tex; mode=display">sigmoid(x)^{'}=sigmoid(x)(1-sigmoid(x))</script></li></ul></li><li>tanh<ul><li>原函数<script type="math/tex; mode=display">tanh(x)=\dfrac{e^x-e^{-x}}{e^x+e^{-x}}=2sigmoid(2x)-1</script></li><li>导数<script type="math/tex; mode=display">tanh(x)^{'}=1-tanh(x)^2</script></li></ul></li><li>ReLU(线性整流单元)<ul><li>原函数<script type="math/tex; mode=display">f(x)=\begin{cases}x &\text{if } x\ge0 \\ 0 &\text{if }x<0\end{cases}</script></li><li>导数<script type="math/tex; mode=display">f(x){'}=\begin{cases}1 &\text{if } x\ge0 \\ 0 &\text{if }x<0\end{cases}</script></li></ul></li><li>leakly ReLU<ul><li>原函数<script type="math/tex; mode=display">f(x)=\begin{cases}x &\text{if } x\ge0 \\ \alpha{x} &\text{if }x<0\end{cases}\left(\alpha=0.1\right)</script></li><li>导数<script type="math/tex; mode=display">f(x){'}=\begin{cases}1 &\text{if } x\ge0 \\ \alpha &\text{if }x<0\end{cases}(\alpha=0.1)</script></li></ul></li><li>ELU (SELU)<ul><li>原函数<script type="math/tex; mode=display">f(x)=\begin{cases}x &\text{if } x\ge0 \\ \alpha\left({e^x-1}\right) &\text{if }x<0\end{cases}\left(\alpha=0.1\right)</script></li><li>导数<script type="math/tex; mode=display">f(x){'}=\begin{cases}1 &\text{if } x\ge0 \\ \alpha{e^x} &\text{if }x<0\end{cases}(\alpha=0.1)</script></li></ul></li><li>GELU<ul><li>原函数<script type="math/tex; mode=display">f(x)=0.5x(1+tanh(\sqrt{\dfrac{2}{\pi}}(x+0.44715x^3)))</script></li><li>导数</li></ul></li><li>softmax<ul><li>原函数<script type="math/tex; mode=display">f(x)=\dfrac{e^{Z_j}}{\sum_{k=1}^{K}{e^{Z_k}}}</script></li><li>导数</li></ul></li><li>Maxout<ul><li>原函数<script type="math/tex; mode=display">f(x)=max(W_1x+b_1, W_2x+b_2)</script></li><li>导数</li></ul></li></ol><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p><em>损失函数是$f(X)$和$Y$的非负实值函数——《统计学习方法》</em></p><ul><li>0-1 损失<script type="math/tex; mode=display">L(f(X),Y)=\begin{cases}1,&Y\not=f(X)\\0, &Y=f(X)\end{cases}</script></li><li>平方损失<script type="math/tex; mode=display">L(f(X),Y)=(Y-f(X))^2</script></li><li>绝对损失<script type="math/tex; mode=display">L(f(X),Y)=|Y-f(x)|</script></li><li>对数损失<script type="math/tex; mode=display">L(Y,P(Y|X))=-\log{P(Y|X)}</script></li><li>均方误差<script type="math/tex; mode=display">MSE=\dfrac{1}{n}(\sum{\hat{y_i}-y_i})^2</script></li></ul><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>用于衡量预测的概率分布和实际概率分布的差异</p><script type="math/tex; mode=display">Cross-Entropy=-\sum_{i=1}^np(x_i)\log(q(x_i))</script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS224N-Lecture5-notes</title>
      <link href="/2020/04/02/CS224N/CS224N-Lecture5-notes/"/>
      <url>/2020/04/02/CS224N/CS224N-Lecture5-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="CS224N-Assignment-3-Neural-Dependency-Parser"><a href="#CS224N-Assignment-3-Neural-Dependency-Parser" class="headerlink" title="CS224N Assignment 3 Neural Dependency Parser"></a>CS224N Assignment 3 Neural Dependency Parser</h1><h2 id="需要理清楚的细节问题"><a href="#需要理清楚的细节问题" class="headerlink" title="需要理清楚的细节问题"></a>需要理清楚的细节问题</h2><p>网络结构</p><ol><li>输入数据的形式<ul><li>原始输入数据分为3个部分：Word，POS，Label（单词，词性标签，弧的类型）。处理后的输入数据$[x^w, x^t, x^l]$</li><li>其中word是按照一定的规则从数据中抽取的特征，包含18个词（stack，buffer栈顶6个 + stack栈顶2个单词的最左2个，最右2个 + stack栈顶两个元素的最左，最右的最左最右单词，共计4个）</li><li>3个特征都需要Embedding</li></ul></li><li>Embedding是从已经训练好的文件中加载的还是训练过程中同步训练出来的？<ul><li>使用的是预训练好的Embedding矩阵，位置<code>./data/en_cw.txt</code></li></ul></li><li>各层模型对数据类型的具体要求<ul><li><strong>存疑</strong></li></ul></li><li>mini_batch的问题，怎样划分mini_batch,每个batch的数据是同时输入做训练还是batch内部有区别<ul><li>针对本作业：minibatch的划分是为了按照批次处理数据，由于句子的长度不同，需要处理的步数不同，因此每个批次的数据不是按照固定的步骤数生成，而是每批次数据都需要等到该批次数据全部解析完。</li><li>其他：这里用到的参数是batch_size, 那么数据一共能分成<code>dataset_size / batch_szie</code>向下取整个batch</li></ul></li><li>loss值的计算，这里用的是softmax，Pytorch中不同的损失值的计算的输入，输出，对数据类型的要求是什么，形状是什么<ul><li>这里的输出对应transition的3种类型，是一个1*3的向量，每个元素对应该类别的概率。因此最终采用交叉熵计算loss值。</li></ul></li><li>UAS的计算方式。神经网络预测出的结果，最终是通过什么方式评估，量化并得到最终的评分的，标注好的数据集是什么形式<ul><li>Unlabeled attachment score (UAS) = head</li><li>也就是说UAS只需要关注弧的指向是否正确，而不关注弧的标签是否正确。因此，与之对应的：LAS（Labeled attachment score）两者都关注</li></ul></li><li>tqdm进度条的使用方法</li><li>dropout的概率参数是指的保留的神经元数目还是指的丢弃的神经元数目。<ul><li>dropout：训练的时候使用，随机把隐含层的单元设为0(每个批次drop不同的单元)，然后将隐含层和一个常数$r$相乘得到$h_{drop}$。这个常数使得$h_{drop}$的期望和$h$的期望相同</li><li>dropout层的目的是防止过拟合</li></ul></li><li>dropout层是一个单独的层还是仅仅是作用于隐含层上的一个函数<ul><li>是一个单独的层，只用于训练的时候，为了防止过拟合。（因此一般加在全连接层后面）</li><li>drop prop的意义是隐含层的单元有drop prop的概率会被”drop“</li></ul></li><li>Adam算法的思路回顾</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>对CS224N的第5课有了更深入的理解</li><li>实际使用PyTorch搭建了神经网络，对这个问题有所了解了</li><li>更深地理解了从<code>原始数据-&gt;特征抽取-&gt;嵌入-&gt;训练-&gt;验证</code>这个过程</li><li>理解了每次课讲的<code>评估</code>这个部分</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> CS224N </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 笔记 </tag>
            
            <tag> CS224N </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习笔记</title>
      <link href="/2020/03/06/other/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/03/06/other/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="刷题笔记"><a href="#刷题笔记" class="headerlink" title="刷题笔记"></a>刷题笔记</h1><h2 id="Sample-Level"><a href="#Sample-Level" class="headerlink" title="Sample Level"></a>Sample Level</h2><ul><li><p>排序</p><ul><li><p>B1015/A1062:</p><p>  这是一道分类排序题，可以将成绩分成5个类别，最后一个类别不用输出。</p><p>  思路一：将类别作为结构体的一个成员，将所有学生进行排序（快速排序算法），平均复杂度为：$O(NlogN)$。<br>  思路二：分类存储每一类成绩，再分别对其排序。</p><p>  <strong>超时问题</strong>：</p><p>  最开始以为是因为排序算法的复杂度过高导致的超时，后经查阅其他人的博客发现，超时的原因是<strong>cin的速度比较慢，这里应该使用scanf函数来控制输入</strong>，如果使用cin函数，应该使用以下函数<code>ios::sync_with_stdio(false)</code>以取消<code>cin</code>和<code>cout</code>的同步机制（但是这种方法还是比<code>scanf</code>慢，因此此题建议使用<code>scanf</code></p><p>  总结：</p><ol><li><p>基本排序算法的实现-快速排序</p><p> 快速排序每次选择一个哨兵<code>i</code>作为标准，将整个序列分成两个部分：大于<code>i</code>的元素和小于<code>i</code>的元素。通过递归每次将两个部分再次进行排序，最终完成对序列整体的排序。</p><p> 代码实现：</p><pre class=" language-lang-(C++)"><code class="language-lang-(C++)"> // 函数中的compare函数自己实现 void quick_sort(Student students[], int start, int ends){     if(start < ends){         int low = start, high = ends;         Student tmp = students[low];         while(low < high){//把数组分成两个部分：应该排在tmp前面的和后面的             while(low < high && compare(tmp, students[high]) == true){                 //如果tudents[high]排在tmo的后面                 high--;             }             students[low] = students[high];             while(low < high && compare(tmp, students[low]) == false){                 low++;             }             students[high] = students[low];         }         students[low] = tmp;         quick_sort(students, start, low-1);         quick_sort(students, low+1, ends);     } }</code></pre></li><li><p>使用库函数：<code>sort()</code>函数的使用方法</p><p> 下面简单介绍sort()函数的使用方法：</p><p> <code>sort()</code>函数包含在<code>algorithm</code>库中</p><p> <strong>Sorting:</strong><br> | method name | function |<br> | :—————-:|:—————:|<br> | sort |Sort elements in range (function template ) |<br> | stable_sort | Sort elements preserving order of equivalents (function template ) |<br> | partial_sort | Partially sort elements in range (function template )|<br> |partial_sort_copy|Copy and partially sort range (function template )|<br> |is_sorted | Check whether range is sorted (function template )|<br> | is_sorted_until| Find first unsorted element in range (function template )|<br> | nth_element|Sort element in range (function template )|</p><p> <code>sort</code>的功能是对一个区间内的元素进行排序，默认非降序排序，可以通过自己实现compare函数控制排序。（不稳定排序，如果需要使用稳定排序，可以使用<code>stable_sort</code>函数进行排序）</p><p> <code>sort(first, last, comp)</code>对$[first, last)$范围内的元素进行排序（左开右闭）</p><p> <code>comp</code>参数是一个函数指针，这个函数应该返回一个<code>bool</code>值，sort函数根据bool值进行排序。</p><p> e.g.,</p><p> <code>bool comp(Elem a, Elem b)</code>返回<code>true</code>, 则表示排序过程中，<code>a</code>应该排在<code>b</code>的<strong>前面</strong>。</p><p> 实例1，vector排序：</p><pre class=" language-lang-(C++)"><code class="language-lang-(C++)"> bool compare(Stu &s1, Stu &s2){     int flag = false;     if(s1.sum != s2.sum) return s1.sum > s2.sum;     else if(s1.de != s2.de) return s1.de > s2.de;     else return s1.id < s2.id;     return flag; } //省略其他代码， stus是一个vector数组 for(int i = 0; i < 4; i++){     sort(stus[i].begin(), stus[i].end(), compare); }</code></pre><p> 实例2，数组排序：</p><pre class=" language-lang-(C++)"><code class="language-lang-(C++)"> //students是长度为m的数组 sort(students, students + m, compare);</code></pre></li><li><p><code>algorithm</code>库中可以使用的其他排序算法（见上表）</p></li><li>涉及到排序问题的关键在于怎样实现compare函数，通常根据题目的条件来实现相应的compare函数</li></ol></li><li><p>子问题：排名(Rank)</p><p>排名问题的要点在于：如果存在相同分数的记录，排名应该保持相同，直到下一个分数出现才累计排名。</p><p>e.g., 1，2，2，4，5，5，5，8</p><ul><li><p>A1012</p><ul><li>简单的模拟题，最开始被我弄得很复杂，最终参考题解的代码如下：</li></ul><pre class=" language-lang-(C++)"><code class="language-lang-(C++)">#include<iostream>#include<stdlib.h>#include<stdio.h>#include<math.h>#include<algorithm>using namespace std;const int maxn=2010;struct student{    int id;    int grade[4];};char course[4]={'A','C','M','E'};student stu[maxn];int RANK[10000000][4]={0};int now;//当前第几门课bool cmp(student a,student b){    return a.grade[now]>b.grade[now];}int main(){    int N,M;    scanf("%d%d",&N,&M);    for(int i=0;i<N;i++){        scanf("%d%d%d%d",&stu[i].id,&stu[i].grade[1],&stu[i].grade[2],&stu[i].grade[3]);        stu[i].grade[0]=round((stu[i].grade[1]+stu[i].grade[2]+stu[i].grade[3])/3.0)+0.5;    }    for(now=0;now<4;now++){        sort(stu,stu+N,cmp);        RANK[stu[0].id][now]=1;        for(int i=1;i<N;i++){            if(stu[i].grade[now]==stu[i-1].grade[now]){                RANK[stu[i].id][now]=RANK[stu[i-1].id][now];            }else{                RANK[stu[i].id][now]=i+1;            }        }    }    int query;    for(int i=0;i<M;i++){        scanf("%d",&query);        if(RANK[query][0]==0){            printf("N/A\n");        }else{            int k=0;            for(int j=0;j<4;j++){                if(RANK[query][j]<RANK[query][k]){                    k=j;                }            }            printf("%d %c\n",RANK[query][k],course[k]);        }    }    system("pause");    return 0;}</code></pre></li><li><p>A1025</p></li></ul><p>题目是合并几块无序数据，并且按照分数进行总的排序。最终输出总排名和局部排名。</p></li></ul></li><li><p>简单Hash问题</p><ul><li>常用思路:<ul><li>ASCII码散列，处理字符串相减等问题</li><li>检查某些项是否出现</li><li>两数相加问题</li></ul></li><li>简单问题中，可以通过使用散列的方法，降低时间复杂度。重点是在这个过程中，应该要考虑好散列表的大小，确保数据完全散列到表内。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习方法学习笔记</title>
      <link href="/2020/03/04/other/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/04/other/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="统计学习方法学习笔记"><a href="#统计学习方法学习笔记" class="headerlink" title="统计学习方法学习笔记"></a>统计学习方法学习笔记</h1><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>本部分主要讲述了：</p><ul><li>统计学习的研究内容</li><li>统计学习的三要素</li><li>监督学习的学习方法</li><li>对于模型的评价</li><li>监督学习的三个子问题</li></ul><ol><li>统计学习<ul><li>假设数据有统计规律</li><li>通过对数据进行分析，发现其中的知识</li><li>学习： 一个系统通过执行某个过程来改进它的性能</li><li>目的是对数据进行预测和分析</li><li>主要方法<ul><li>监督学习(supervised learning)</li><li>非监督学习(insupervised learning)</li><li>半监督学习(semi-supervised learning)</li><li>强化学习(reinforcement learning)</li></ul></li></ul></li><li>监督学习<ul><li>任务：学习一个模型。该模型能够对输出产生较好的预测结果</li><li>基本概念：<ol><li>输入空间，特征空间，输出空间</li><li>联合概率分布，条件概率（决策函数）</li><li>假设空间</li></ol></li></ul></li><li><p>统计学习三要素</p><ul><li>模型：模型的假设空间，即需要学习的函数属于的某一个函数空间<ol><li>通过模型学习输入和输出的联合概率密度（生成方法）或者条件概率密度（判别方法，也叫决策函数）</li></ol></li><li><p>策略：模型选择的准则，用于评价假设空间中的模型，以选择一个最优模型</p><ol><li>损失函数(loss function)/代价函数(cost function):<blockquote><ul><li>衡量模型一次预测的好坏</li><li>wait to insert LaTex function<ul><li>0-1(0-1 loss function)</li><li>平方损失(quadrtic loss function)</li><li>绝对损失(absolute loss function)</li><li>对数损失(logarithmic loss function)</li></ul></li></ul></blockquote></li><li><p>风险函数(risk function)</p><blockquote><ul><li>平均意义下的模型的好坏，</li></ul></blockquote><p> 损失函数的期望,即风险函数(risk function)或者是期望损失(expected loss)</p><p> 因为风险函数中的联合概率分布未知，因此使用经验风险估计期望风险。(当样本数量足够多的时候可行，实际中样本往往较少，因此需要对这个函数进行修正)</p></li><li>经验风险(empirivcal risk)/经验损失(empirical loss)<ul><li>训练集上的平均损失</li><li>矫正策略：<ul><li>经验风险最小化（容易引起过拟合(overfitting)）</li><li>结构风险最小化<ul><li>同时表示模型的经验风险和模型的复杂度</li><li>正则化</li></ul></li><li>将统计学习问题转化为最优化问题</li></ul></li></ul></li></ol></li><li>算法：模型学习的算法<ul><li>统计学习归结为最优化问题，因此可采用最优化算法来求解最优化模型</li></ul></li></ul></li><li>模型评估<ul><li>训练误差：训练数据集的平均损失<ul><li>可以判断该问题是否可以学习，但是本质上是不重要的</li></ul></li><li>测试误差：测试数据集的平均损失<ul><li>测试误差用于判断模型的泛化能力，决定模型的好坏</li></ul></li></ul></li><li>模型选择<ul><li>过拟合<ul><li>选择的模型复杂度比较高（比实际模型高）</li><li>包含参数过多</li></ul></li><li>模型选择<ul><li>复杂度适当</li></ul></li></ul></li><li>正则化和交叉验证<ul><li>正则化：<ul><li>在经验风险的基础上增加正则化项或者罚项。</li></ul></li><li>交叉验证<ul><li>在数据集不足的时候重复使用数据来对模型进行验证</li><li>简单交叉验证<ul><li>随机拆分数据为训练集和测试机</li><li>在不同的条件下训练模型，在测试集上测试这些模型，选择最好的</li></ul></li><li>S折交叉验证(S-fold cross validation)<ul><li>将数据集分成S个不相交子集，S-1个用于训练，1个用于测试</li><li>重复所有S种可能，选择平均测试误差最小的模型</li></ul></li><li>留一交叉验证(leave one out cross validation)<ul><li>S-fold的特殊情况，S=N</li></ul></li></ul></li></ul></li><li>泛化能力<ul><li>评价标准：泛化误差上界</li><li>泛化误差(generalization ability)</li><li>泛化误差上界：<ul><li>是N（样本容量）的函数，N增大，上界-&gt;0</li><li>是假设空间容量的函数，capacity越大，上界越大</li></ul></li><li>二分类问题的泛化误差上界</li></ul></li><li>生成模型和判别模型<ul><li>生成模型：学习的是X，Y的联合分布函数g(X,Y)<ul><li>朴素贝叶斯</li><li>隐马尔可夫</li></ul></li><li>判别模型：学习的是X,Y的条件概率分布（也即决策函数）<ul><li>K-近邻</li><li>感知机</li><li>决策树</li><li>逻辑斯蒂回归</li><li>最大熵</li><li>支持向量机</li><li>提升方法</li><li>条件随机场</li></ul></li></ul></li><li>分类问题（连续/离散输入 —&gt; 离散输出）<ul><li>二分类<ul><li>预测情况：<ul><li>TP: True Positive</li><li>FN: False Negetive</li><li>TN: True Negetive</li><li>FP: False Positive</li></ul></li><li>评价标准：<ul><li>精确率(precision)</li><li>召回率(recall)</li><li>F1值</li></ul></li></ul></li><li>多分类</li></ul></li><li>标注问题（序列输入 —&gt; 序列输出）<ul><li>分类问题的推广</li><li>结构预测的简单形式</li><li>输入：观测序列</li><li>输出：标记序列或者是状态序列</li></ul></li><li>回归问题<ul><li>预测输入变量和输出变量的关系</li><li>等价于函数拟合</li><li>分类<ul><li>按输入维度：<ul><li>一元回归</li><li>多元回归</li></ul></li><li>按模型类型<ul><li>线性</li><li>非线性</li></ul></li></ul></li></ul></li></ol><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><blockquote><p>二类分类，线性模型</p></blockquote><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li><p>特征空间中的线性分类模型的集合，属于判别模型（模型是一个输入和输出是线性关系）</p><script type="math/tex; mode=display">f(x) = sign(w\cdot{x}+b)</script></li><li><p>输入：n维特征向量 $x$</p></li><li>输出：$y=+1$或者$y=-1$</li><li>参数：<ul><li>$w$：超平面的法向量，</li><li>$b$：超平面的截距</li></ul></li></ul><h3 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h3><ul><li>损失函数极小化</li><li>误分类点</li><li><p>损失函数：误分类点到超平面的总距离</p><p>  $-\dfrac{1}{|w|}\displaystyle\sum_{x_i\in M}|w\cdot{x_i}+{b}|$</p></li><li>$|w|$是$w$的$L_2$范数</li></ul><h3 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h3><ul><li>随机梯度下降（SGD）</li><li>原始形式<ul><li>w表示为原始形式</li></ul></li><li>对偶形式<ul><li>w用$\displaystyle\sum_{i=1}^N{\alpha_iy_ix_i}$表示</li></ul></li></ul><h2 id="k-近邻"><a href="#k-近邻" class="headerlink" title="k-近邻"></a>k-近邻</h2><p>基本的回归和分类方法</p><blockquote><p>特征空间划分</p></blockquote><ul><li>原理<ul><li>根据k个<strong>最近邻</strong>的实例确定新实例的类别，例如通过多数表决确定</li></ul></li><li>三要素<ul><li>距离度量<ul><li>欧式距离($L_2$距离)</li><li>$L_p$距离：$L_p(x_i,x_j)=(\displaystyle\sum_{l=1}^n{|x_i^{(l)}-x_j^{(l)}|}^p)^\frac{1}{p}$</li><li>Minkowski距离</li></ul></li><li>k值的选择<ul><li>k小：近似误差小，估计误差大</li><li>k大：近似误差大，估计误差小</li></ul></li><li>分类决策规则<ul><li>多数表决</li></ul></li></ul></li><li>实现<ul><li>线性扫描</li><li>kd树（这里的k表示空间的维度k）</li></ul></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><p>基于贝叶斯定理、特征条件独立假设、分类方法</p><ul><li>学习的是联合概率分布</li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><ul><li>基本分类和回归方法</li></ul><h2 id="逻辑斯蒂回归和最大熵"><a href="#逻辑斯蒂回归和最大熵" class="headerlink" title="逻辑斯蒂回归和最大熵"></a>逻辑斯蒂回归和最大熵</h2><h2 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h2><h2 id="提升方法"><a href="#提升方法" class="headerlink" title="提升方法"></a>提升方法</h2><h2 id="EM算法及其推广"><a href="#EM算法及其推广" class="headerlink" title="EM算法及其推广"></a>EM算法及其推广</h2><h2 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h2><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS224N 学习笔记 Lecture 1,2 Word2Vec</title>
      <link href="/2020/03/04/CS224N/CS224N-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lecture-1-2-Word2Vec/"/>
      <url>/2020/03/04/CS224N/CS224N-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lecture-1-2-Word2Vec/</url>
      
        <content type="html"><![CDATA[<h1 id="CS224n-课程学习笔记-1"><a href="#CS224n-课程学习笔记-1" class="headerlink" title="CS224n 课程学习笔记 1"></a>CS224n 课程学习笔记 1</h1><p>本节内容： Word2Vec</p><a id="more"></a><p><a href="https://www.bilibili.com/video/av61620135" target="_blank" rel="noopener">课程视频地址</a></p><h2 id="课程内容要点"><a href="#课程内容要点" class="headerlink" title="课程内容要点"></a>课程内容要点</h2><ul><li>理解Word Vector</li><li>基于词汇共现(word co-occurence)的word vector</li><li>word2vec模型</li><li>深入理解word2vec模型（具体的模型结构，公式推导及优化方法）</li><li>理解word2vec源码（google开源）</li></ul><h3 id="理解Word-Vector"><a href="#理解Word-Vector" class="headerlink" title="理解Word Vector"></a>理解Word Vector</h3><p>word vector是为了将文本数据转化为计算机能够计算的数字数据。</p><p>word vector: 将自然语言中的每个单词编码为一个向量，这个向量是对应的单词在某种“单词”空间(word space)中的一个点。</p><p>这样做的主要原因是：</p><p>我们认为存在某些$N (N &lt;= |V|)$维空间可以将某种语言的语义信息全部编码。</p><p>最简单的编码方式：<strong>one-hot vector</strong>。也就是把所有单词看作一个词汇表，除了相应的位置值为1，其他所有位置的值均为0.其缺点在于：</p><ol><li>这种表示方式过于稀疏，计算量极大</li><li>one-hot表示方式不能体现出单词之间的语义关系</li></ol><h3 id="基于SVD-Singular-Value-Decomposition-奇异值分解-的方法"><a href="#基于SVD-Singular-Value-Decomposition-奇异值分解-的方法" class="headerlink" title="基于SVD(Singular Value Decomposition, 奇异值分解) 的方法"></a>基于SVD(Singular Value Decomposition, 奇异值分解) 的方法</h3><p>基本思想：<br>通过统计单词共现(word co-occurrence)的次数形成一个巨大的共现矩阵(co-occurrrence matrix)，然后通过奇异值分解的方法降维，得到一个$|V|\times{k}$的矩阵，每一行即为对应的word vector。</p><p>求共现矩阵的两种方法：</p><ol><li>word-document matrix<ul><li>矩阵的每行表示一个词汇表中的单词，每列表示一个文件</li><li>扫描所有语料文件，每次单词$Wi$在document$Dj$中出现，则矩阵中相应元素$M_{ij}$计数增加</li></ul></li><li>window based co-occurrence matrix<ul><li>和word-document maticx方法类似，每行的行向量最终对应单词的word vector，区别在于这里每列表示相应单词在每行所表示的单词的窗口范围内出现的次数。</li><li>统计每个单词$W_j$出现在中心词$W_i$的窗口范围内的次数</li><li>这里的重要参数是window size</li></ul></li></ol><p>SVD将共现矩阵分解为三个矩阵相乘的形式: $X_{|V|\times|V|} = U_{|V|\times|V|}S_{|V|\times|V|}V_{|V|\times|V|}$</p><p>其中矩阵$S$是一个对角矩阵，通过取$S$矩阵中的$k$列与$U$最终得到word vector矩阵（$|V|\times{k}$）</p><h3 id="基于迭代的方法-Word2Vec"><a href="#基于迭代的方法-Word2Vec" class="headerlink" title="基于迭代的方法: Word2Vec"></a>基于迭代的方法: Word2Vec</h3><p>思路：</p><p>建立一个模型，这个模型通过训练最终可以在给出上下文的情况下对单词的概率进行编码。在这个模型里，通过上下文训练模型，而模型中的参数才是最终我们需要求取的所有word vector</p><p>word2vec模型实际上有两种算法：</p><ol><li>CBOW(Continuous bag-of-words)</li><li>SG(skip-gram)</li></ol><p>两种训练方法:</p><ol><li>negative sampling</li><li>hierarchical softmax</li></ol><p>下面对两种算法的细节进行介绍：</p><h4 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h4><p>输入上下文(context),预测中心词(center)</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20181119/20d8cc4a484242b2a67c535736747c9b.jpeg" alt="CBOW模型-图片来自网络，侵删"></p><ul><li>输入：$x_{1k}, x_{2k}, …, x_{ck}$, context的on-hot vector形式</li><li>输入对应的权重矩阵： $W_{|V|\times{n}}$，其中$n$是word vector的编码维数</li><li>输出：$y_j$：ont-hot vector</li><li>对应权重矩阵：$W_{n\times|V|}$</li></ul><p>可以看到，可以得到两个Word Embedding矩阵(Word vector 和 Word Embedding可以换用)，一个对应上下文，一个对应中心词。是一个词在两个位置的向量。</p><p><strong>深入理解</strong></p><p>训练过程：</p><ol><li>为对应的context生成对应的ont-hot向量作为输入$x$</li><li>通过word vectors对输入进行编码(word embedding)$x * W_{input}$</li><li>求其平均值，得到隐藏层的值$h$</li><li>通过$W_{output}$评分：$z = h\cdot{W_{output}}$</li><li>把评分转化为概率分布$\hat{y} = softmax(z)$</li><li>把生成的概率转化为one-hot向量，与实际的中心词$y_j$比较</li></ol><p>目标函数：</p><p>这里采用交叉熵函数(cross-entropy)计算预测分布和实际分布的差距</p><script type="math/tex; mode=display">H(y,\hat{y}) = -\sum_{j=1}^{|V|}y_j\log{\hat{y_j}}</script><h4 id="Skip-Gram"><a href="#Skip-Gram" class="headerlink" title="Skip-Gram"></a>Skip-Gram</h4><p>输入中心词，预测上下文</p><p><img src="http://img5.imgtn.bdimg.com/it/u=1876034502,4074599079&amp;fm=26&amp;gp=0.jpg" alt="Skip-Gram模型-图片来自网络，侵删"></p><h2 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a>Assignment 1</h2><p>简单难度，主要目的是对两种方法有一个直观的理解</p><h2 id="个人体会"><a href="#个人体会" class="headerlink" title="个人体会"></a>个人体会</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> CS224N </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 笔记 </tag>
            
            <tag> CS224N </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
